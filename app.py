import os
import subprocess
import networkx as nx
from node2vec import Node2Vec
import numpy as np
from flask import Flask, request, render_template
from werkzeug.utils import secure_filename
import shutil
from androguard.misc import AnalyzeAPK
from androguard.core.analysis.analysis import ExternalMethod
import pickle

app = Flask(__name__)

model = pickle.load(open("model.pkl", "rb"))

UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'apk'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def generate_call_graph(apk_file):
    call_graph = nx.DiGraph()
    
    # Analyze the APK
    a, d, dx = AnalyzeAPK(apk_file)
    
    # Iterate through methods
    for m in dx.find_methods():
        orig_method = m.get_method()
        if isinstance(orig_method, ExternalMethod):
            is_external = True
        else:
            is_external = False
        
        call_graph.add_node(orig_method, external=is_external)
        
        # Iterate through cross-references
        for other_class, callee, offset in m.get_xref_to():
            if isinstance(callee, ExternalMethod):
                is_external = True
            else:
                is_external = False
            
            if callee not in call_graph.nodes:
                call_graph.add_node(callee, external=is_external)
            
            if not call_graph.has_edge(orig_method, callee):
                call_graph.add_edge(orig_method, callee)
    
    return call_graph

def perform_graph_embedding(call_graph):
    # Generate node2vec embeddings
    node2vec = Node2Vec(call_graph, dimensions=64, walk_length=10, num_walks=30, workers=1)
    model = node2vec.fit(window=10, min_count=1, batch_words=4)
    
    # Get embeddings for all nodes
    node_embeddings = [model.wv[str(node)] for node in call_graph.nodes]
    
    # Aggregate node embeddings to obtain graph embedding
    graph_embedding = np.mean(node_embeddings, axis=0)
    
    return graph_embedding

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        # Check if the post request has the file part
        if 'file' not in request.files:
            return render_template('index.html', message='No file part')
        
        file = request.files['file']
        print(file)
        
        print("******************************************************")
        # If user does not select a file, browser also submits an empty part without filename
        if file.filename == '':
            return render_template('index.html', message='No selected file')
        
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            print(filename)
            try:
                file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            except Exception as e:
                print("An error occurred while saving the file:", e)
            
            apk_file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            print("APK File Path:", apk_file_path)
            
            # Define the output directory
            output_dir = os.path.join(app.config['UPLOAD_FOLDER'], 'decompiled_output')
            print("Output Directory:", output_dir)
            
            # Generating call graph
            call_graph = generate_call_graph(apk_file_path)
            print("one")
            # Perform graph embedding
            graph_embedding = perform_graph_embedding(call_graph)
            print("two")
            # Return the output
            prediction = model.predict([graph_embedding])[0]  # Assuming model.predict takes a list

            if prediction == 1:
                prediction_text = 'Benign'
            else:
                prediction_text = 'Malware'
            
            # Return the output
            return render_template('index.html', message='Prediction: {}'.format(prediction_text))
            
    return render_template('index.html')

if __name__ == '__main__':
    app.run(debug=True)
